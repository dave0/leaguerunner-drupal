<?php
// $Id: ldap_authentication.module,v 1.1.4.3 2011/02/08 20:05:41 johnbarclay Exp $

/**
 * @file
 * This module injects itself into Drupal's Authentication stack.
 */

/**
 * @todo fix advanced help for ../ldap/authentication settings page
 *
 */
define('LDAP_AUTHENTICATION_PROJECT_TAG', 'ldap');

define('LDAP_AUTHENTICATION_MIXED',        1);
define('LDAP_AUTHENTICATION_EXCLUSIVE',    2);
define('LDAP_AUTHENTICATION_MODE_DEFAULT', 1);

define('LDAP_AUTHENTICATION_CONFLICT_LOG',             1);
define('LDAP_AUTHENTICATION_CONFLICT_RESOLVE',         2);
define('LDAP_AUTHENTICATION_CONFLICT_RESOLVE_DEFAULT', 2);

define('LDAP_AUTHENTICATION_EMAIL_UPDATE_ON_LDAP_CHANGE_ENABLE_NOTIFY',  1);
define('LDAP_AUTHENTICATION_EMAIL_UPDATE_ON_LDAP_CHANGE_ENABLE',         2);
define('LDAP_AUTHENTICATION_EMAIL_UPDATE_ON_LDAP_CHANGE_DISABLE',        3);
define('LDAP_AUTHENTICATION_EMAIL_UPDATE_ON_LDAP_CHANGE_DEFAULT',        1);

define('LDAP_AUTHENTICATION_RESULT_FAIL_CONNECT',      1);
define('LDAP_AUTHENTICATION_RESULT_FAIL_BIND',         2);
define('LDAP_AUTHENTICATION_RESULT_FAIL_FIND',         3);
define('LDAP_AUTHENTICATION_RESULT_FAIL_DISALLOWED',   4);
define('LDAP_AUTHENTICATION_RESULT_FAIL_CREDENTIALS',  5);
define('LDAP_AUTHENTICATION_RESULT_SUCCESS',           6);
define('LDAP_AUTHENTICATION_RESULT_FAIL_GENERIC',      7);
define('LDAP_AUTHENTICATION_RESULT_FAIL_SERVER'      , 8);

define('LDAP_AUTHENTICATION_HELP_LINK_TEXT_DEFAULT', 'Logon Help');

/**
 * Implements hook_menu().
 */
function ldap_authentication_menu() {
  $items = array();

  $items['admin/config/people/ldap/authentication'] = array(
    'title' => 'Authentication',
    'description' => 'Configure LDAP Authentication',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ldap_authentication_admin_form'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
    'file' => 'ldap_authentication.admin.inc',
  );

  return $items;
}

 /**
 * Implements hook_menu_alter().
 * since menu items are cached, only useful to add or alter callbacks
 * for ldap authentication driven menu items.
 */
function ldap_authentication_menu_alter(&$items) {
  $items['user/password']['access callback'] = 'ldap_authentication_show_reset_pwd';
  $auth_conf = ldap_authentication_get_valid_conf();
  if (@$auth_conf->ldapUserHelpLinkUrl) {
    $items['user/ldaphelp'] = array(
      'title' => $auth_conf->ldapUserHelpLinkText,
      'page callback' => 'ldap_authentication_redirect_to_ldap_help',
      'access callback' => 'ldap_authentication_show_ldap_help_link',
      'type' => MENU_LOCAL_TASK,
    );
  }
}

function ldap_authentication_redirect_to_ldap_help() {

  if ($auth_conf = ldap_authentication_get_valid_conf() && $auth_conf->ldapUserHelpLinkUrl) {
    drupal_goto($auth_conf->ldapUserHelpLinkUrl);
  }
  else {
    return "Misconfigured LDAP Help Link";
  }

}

function ldap_authentication_theme() {
  return array(
    'ldap_authentication_user_login_block_links' => array(
      'variables' => array('ldap_user_help_link' => NULL, 'user_register' => TRUE),
      'render element' => 'element',
      'file' => 'ldap_authentication.theme.inc'
    ),
   'ldap_authentication_user_pass_message' => array(
      'variables' => array('show_reset_pwd' => NULL, 'auth_conf' => TRUE),
      'render element' => 'element',
      'file' => 'ldap_authentication.theme.inc'
    ),
   'ldap_authentication_user_pass_validate_ldap_authenticated' => array(
      'variables' => array('account' => NULL, 'auth_conf' => TRUE),
      'render element' => 'element',
      'file' => 'ldap_authentication.theme.inc'
    ),
  );
}


/**
 * Implements hook_help().
 */

function ldap_authentication_help($path, $arg) {

  $authentication_help = t('LDAP authentication allows authentication against an LDAP server.  It
        may be used alongside other authentication means such as built in drupal authentication,
        open id, etc.  More detailed help is available on drupal.org at !helplink.',
          array(
            '!helplink' => l(LDAP_SERVERS_DRUPAL_HELP_URL, LDAP_SERVERS_DRUPAL_HELP_URL),
          ));

  switch ($path) {
    case 'admin/config/people/ldap/authentication':
      $output = '<p>' . $authentication_help . '</p>';
      return $output;

    case 'admin/help#ldap_authentication':
      $output = '<p>' . $authentication_help . '</p>';
      return $output;
  }
}

/**
 * Implements hook_info().
 */
function ldap_authentication_info($field = 0) {
  $info['name']= 'ldap_authentication';
  $info['protocol'] = 'LDAP';

  if ($field) {
    return $info[$field];
  }

  return $info;
}


/**
 *
 * @param object $user
 * @return boolean
 *    true if user is recorded as ldap authenticated and identified (ldap_authentified)
 *
 * notes to developers
 * -  make user object explicit for clarity; don't default to current user as admins could be editing profile pages
 * -  don't use $user->data['ldap_authentified'] as it is geared toward ldap_authentication data, not where the user is currently ldap authenticated
 * -
 */
function ldap_authentication_ldap_authenticated($user) {

  if (is_numeric($user)) {
    $user = @user_load((int)$user);
  }
  if (!is_object($user) || $user->uid == 0) {
    return FALSE;
  }

  $authmaps = user_get_authmaps($user->name);
  return isset($authmaps['ldap_authentication']);

}


/**
 * get LdapAuthenticationConf object
 *
 * @return object LdapAuthenticationConf object if configured, otherwise FALSE
 *
 */

function ldap_authentication_get_valid_conf() {
  static $auth_conf;
  if (is_object($auth_conf)) {
    return $auth_conf;
  }
  require_once('LdapAuthenticationConf.class.php');
  $auth_conf = new LdapAuthenticationConf();
  return ($auth_conf->inDatabase) ? $auth_conf : FALSE;

}



function ldap_authentication_show_reset_pwd($user = NULL) {

  if (!$user) {
    global $user;
  }
  $auth_conf = ldap_authentication_get_valid_conf();
  if (current_path() == 'user/password' || $user->uid == 1 || !$auth_conf) {
    return TRUE;
   // always show at user/passwordurl. otherwise user 1 will not be able to reset password.
   // LDAP_authen.login_forms.MM.user1, LDAP_authen.login_forms.EM.user1
  }

  if ($user->uid == 0) {
    // hide reset password for anonymous users if ldap only authentication, otherwise show
    // LDAP_authen.login_forms.MM.anon, LDAP_authen.login_forms.EM.anon
    return ($auth_conf->authenticationMode != LDAP_AUTHENTICATION_EXCLUSIVE);
  }
  else {
    // authenticated user.  hide if ldap authenticated otherwise show.
    // LDAP_authen.login_forms.EM.ldap, LDAP_authen.login_forms.EM.drupal,
    // LDAP_authen.login_forms.MM.drupal, LDAP_authen.login_forms.MM.ldap
    return (!ldap_authentication_ldap_authenticated($user));
  }

}



/**
 * Implements hook_form_alter().
 */
function ldap_authentication_form_alter(&$form, $form_state, $form_id) {

}

/**
 * Implements hook_form_FORM_ID_alter().
 */

function ldap_authentication_form_user_pass_alter(&$form, $form_state) {
  // the following could be in a theme preproces function
  $auth_conf = ldap_authentication_get_valid_conf();
  $form['ldap_warning'] = array(
     '#type' => 'item',
     '#markup' => theme('ldap_authentication_user_pass_message', array('auth_conf' => $auth_conf)),
     '#weight' => 10,
      );

  // need to insert before user_pass_validate
  array_unshift($form['#validate'], 'ldap_authentication_user_pass_validate');
}


function ldap_authentication_user_pass_validate(&$form_state) {
  $name_or_mail = trim($form_state['name']['#value']);
  if ($account = user_load_by_mail($name_or_mail)) {

  }
  else {
    $account = user_load_by_name($name_or_mail);
  }

  if (ldap_authentication_ldap_authenticated($account)) {
    $vars = array(
      'account' => $account,
      'auth_conf' => ldap_authentication_get_valid_conf(),
    );
    form_set_error('name', theme('ldap_authentication_user_pass_validate_ldap_authenticated', $vars));
  }
}
/**
 * Implements hook_form_FORM_ID_alter().
 */

function ldap_authentication_form_user_register_alter(&$form, $form_state) {

}

/**
 * Implements hook_form_FORM_ID_alter(). for user_profile_form
 */
function ldap_authentication_form_user_profile_form_alter(&$form, $form_state) {
  // keep in mind admin may be editing another users profile form.  don't assume current global $user
  $auth_conf = ldap_authentication_get_valid_conf();
  if ($auth_conf && ldap_authentication_ldap_authenticated($form['#user'])) {
    // Always hide email field; it's a Leaguerunner preference to enable
    // viewing based on user permissions and team membership, so we don't
    // want to display in Drupal.
    $form['account']['mail']['#type'] = 'hidden';

    if (!ldap_authentication_show_reset_pwd($form['#user'])) {
      $form['account']['current_pass']['#disabled'] = TRUE;
      $form['account']['pass']['#disabled'] = TRUE;
    }
  }
}


/**
 * Implements hook_form_FORM_ID_alter(). for user_login
 */
function ldap_authentication_form_user_login_alter(&$form, &$form_state) {
  _ldap_authentication_login_form_alter($form, $form_state, 'user_login');

}

/**
 * Implements hook_form_FORM_ID_alter(). for user_login_block
 */
function ldap_authentication_form_user_login_block_alter(&$form, &$form_state) {
  _ldap_authentication_login_form_alter($form, $form_state, 'user_login_block');

}

/**
 * validate function for user logon forms.

 * user form validation will take care of username, pwd fields
 *
 * this may validate if the user exists in ldap in the case of using
 * ldap authentication exclusively
 */
function ldap_authentication_user_login_authenticate_validate($form, &$form_state) {
  $detailed_watchdog_log = variable_get('ldap_help_watchdog_detail', 0);
  $name = $form_state['values']['name'];
  $pass = $form_state['values']['pass'];
  $watchdog_tokens = array('%username' => $name);

  if (!$auth_conf = ldap_authentication_get_valid_conf()) {
    watchdog('ldap_authentication', 'Failed to get valid ldap authentication configuration.', array(), WATCHDOG_ERROR);
    form_set_error('name', 'Server Error: Failed to get valid ldap authentication configuration.' . $error);
    return FALSE;
  }

 // if already succeeded at authentication, see if LDAP Exclusive is set
  if (isset($form_state['uid']) && is_integer($form_state['uid'])) {
    if ($auth_conf->authenticationMode == LDAP_AUTHENTICATION_MIXED || $form_state['uid'] == 1) {
      if ($detailed_watchdog_log) {
      watchdog('ldap_authentication', '%username : Previously authenticated in mixed mode or uid=1', $watchdog_tokens, WATCHDOG_DEBUG);
      }
      return;  // already passed previous authentication validation
    }
    elseif ($auth_conf->authenticationMode == LDAP_AUTHENTICATION_EXCLUSIVE) {
      if ($detailed_watchdog_log) {
        watchdog('ldap_authentication', '%username : Previously authenticated in exclusive mode or uid is not 1.  Clear uid
        in form_state and attempt ldap authentication.',  $watchdog_tokens, WATCHDOG_DEBUG);
      }
      $form_state['uid'] = NULL;  // passed previous authentication, but only ldap should be used
    }
  }

  if (!count($auth_conf->servers)) {
    watchdog('ldap_authentication',  'No LDAP servers configured.', array(), WATCHDOG_ERROR);
    form_set_error('name', 'Server Error:  No LDAP servers configured.');
  }

  if ($detailed_watchdog_log) {
    watchdog('ldap_authentication', '%username : user_load_by_name(%username)', $watchdog_tokens, WATCHDOG_DEBUG);
  }

  $account = user_load_by_name($name);
  if (is_object($account)) {
    if ($account->uid == 1) {
      if ($detailed_watchdog_log) {
        watchdog('ldap_authentication',  '%username : Drupal username maps to user 1, so do not authenticate with ldap', $watchdog_tokens, WATCHDOG_DEBUG);
      }
      return FALSE;  // user 1 must use drupal authentication
    }
    else {
      $account_exists = TRUE;
      $user_data = $account->data;
      $authmaps = user_get_authmaps($name);
      $ldap_authentication_authmap = isset($authmaps['ldap_authentication']);
      $no_authmaps = (boolean)(count($authmaps));
      if ($detailed_watchdog_log) {
        watchdog('ldap_authentication',  '%username : Drupal User Account found.  Continuing on to attempt ldap authentication', $watchdog_tokens, WATCHDOG_DEBUG);
      }
    }
  }
  else {  // account does not exist
    $account_exists = FALSE;
    if ($detailed_watchdog_log) {
      watchdog('ldap_authentication', '%username : Exisitng Drupal User Account not found.  Continuing on to attempt ldap authentication', $watchdog_tokens, WATCHDOG_DEBUG);
    }
  }

  // Authenticate
  $curl = curl_init();
  curl_setopt($curl, CURLOPT_URL, 'http://www.ocua.ca/leaguerunner/api/2/login');
  curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);
  curl_setopt($curl, CURLOPT_CONNECTTIMEOUT, 1);

  curl_setopt($CURL, CURLOPT_POST, TRUE);
  curl_setopt($curl, CURLOPT_POSTFIELDS, array(
	'username' => $name,
	'password' => $pass,
	'remote_addr' => $_SERVER['REMOTE_ADDR'],
	'cookie' => session_id(),
  ));

  if( ! $xml = curl_exec( $curl ) ) {
    $watchdog_tokens['%sid'] = $sid;
    $watchdog_tokens['%curl_error'] = curl_error();
    if ($detailed_watchdog_log) {
      watchdog('leaguerunner_authentication', '%username : Failed against server %sid with error: %curl_error', $watchdog_tokens, WATCHDOG_DEBUG);
    }
    form_set_error('name', 'Failed to authenticate against Leaguerunner');
    curl_close($curl);
    return FALSE;
  }
  curl_close($curl);

  // Check result
  $xmlObj = simplexml_load_string($xml);
  if( ! $xmlObj->status == 'ok' ) {
    form_set_error('name', 'Login failed: ' . $xmlObj->error);
    return FALSE;
  }

  // OK, we're in, and have XML data containing the user's full name and possibly other info

  /**
   * case 1: previously drupal authenticated user authenticated successfully on ldap
   *
   */
  if (!$account_exists) {
/*
  // TODO: do we care?  Leaguerunner allows duplicate email addresses

    if ($account_with_same_email = user_load_by_mail($ldap_user['mail'])) {
      // 
      // username does not exist but email does.  Since user_external_login_register does not deal with
      // mail attribute and the email conflict error needs to be caught beforehand, need to throw error here
      //
      $watchdog_tokens['%duplicate_name'] = $account_with_same_email->name;
      watchdog('ldap_authentication', 'LDAP user with DN %dn has email address
        (%mail) conflict with a drupal user %duplicate_name', $watchdog_tokens, WATCHDOG_ERROR);
      drupal_set_message(t('Another user already exists in the system with the same email address. You should contact the system administrator in order to solve this conflict.'), 'error');
      return FALSE;

    }
*/
    /**
     *
     * new ldap_authentication provisioned account could let user_external_login_register create the account and set authmaps, but would need
     * to add mail and any other user->data data in hook_user_presave which would mean requerying ldap
     * or having a global variable.  At this point the account does not exist, so there is no
     * reason not to create it here.
     *
     * @todo create patch for user_external_login_register to deal with new external accounts
     *       a little tweak to add user->data and mail etc as parameters would make it more useful
     *       for external authentication modules
     */
    require_once(drupal_get_path('module', 'ldap_servers') . '/ldap_servers.functions.inc');
    $account = ldap_create_drupal_account($name, $ldap_user['mail'], $ldap_user['dn'], $sid);
    if ($account === FALSE) {
      // need to throw error that account was not created
    }


  }
  else {  // account already exists
    if ($ldap_authentication_authmap == FALSE) {  // LDAP_authen.AC.disallow.ldap.drupal
      // TODO purge code of loginConflictResolve and LDAP_AUTHENTICATION_CONFLICT_*
      // add ldap_authentication authmap to user.  account name is fine here, though cn could be used
      user_set_authmaps($account, array('authname_ldap_authentication' => $name));
      if ($detailed_watchdog_log) {
          watchdog('ldap_authentication', 'set authmap for %username authname_ldap_authentication', $watchdog_tokens, WATCHDOG_DEBUG);
      }
    }
/*
// TODO: again, do we care about email?
    if ($account->mail != $ldap_user['mail'] && (
          $auth_conf->emailUpdate == LDAP_AUTHENTICATION_EMAIL_UPDATE_ON_LDAP_CHANGE_ENABLE_NOTIFY ||
          $auth_conf->emailUpdate == LDAP_AUTHENTICATION_EMAIL_UPDATE_ON_LDAP_CHANGE_ENABLE
          ))  {
      $edit = array('mail' => $ldap_user['mail']);
      if (!$updated_account = user_save($account, $edit)) {
        $watchdog_tokens = array('%username' => $account->name, '%old' => $account->mail, '%new' => $ldap_user['mail']);
        watchdog('ldap_authentication', 'User e-mail for %username update from %old to %new failed because of system problems.', $watchdog_tokens,  WATCHDOG_ERROR);
      }
      elseif ($auth_conf->emailUpdate == LDAP_AUTHENTICATION_EMAIL_UPDATE_ON_LDAP_CHANGE_ENABLE_NOTIFY ) {
          $message_tokens = array('@mail' => $ldap_user['mail']);
          drupal_set_message(t('Your e-mail has been updated to match your LDAP account (@mail).', $message_tokens), 'status');
      }
*/
  }

  /**
  * we now have valid, ldap authenticated username with an account authmapped to ldap_authentication.
  * since user_external_login_register can't deal with user mail attribute and doesn't do much else, it is not
  * being used here.
  */


  /**
   * without doing the user_login_submit,
   * [#1009990]
   *
   */
  $fake_form_state['uid'] = $account->uid;

  user_login_submit(array(), $fake_form_state);
  global $user;
  $form_state['uid'] = $user->uid;
  return;

}

/**
 * Implements hook_user_login().
 *
 * The user just logged in.
 *
 */

function ldap_authentication_user_login(&$edit, $account) {

}


/**
 * Implements hook_user_presave().
 *  A user account is about to be created or updated.
 */

function ldap_authentication_user_presave(&$edit, $account, $category = NULL) {

}


/**
 * Implements hook_user_insert().
 *
 * A user account was created.
 * The module should save its custom additions to the user object into the database.
 */

function ldap_authentication_user_insert(&$edit, $account, $category) {

}


/**
 * Implements hook_user_update().
 *
 *  A user account was updated.
 *  Modules may use this hook to update their user data in a custom storage after a user account has been updated.
 */


function ldap_authentication_user_update($edit, $user, $category) {

}

function ldap_authentication_show_ldap_help_link($user = NULL) {
  global $user;

  if (!$auth_conf = ldap_authentication_get_valid_conf()) {
    return FALSE;
  }

  if ($auth_conf->authenticationMode == LDAP_AUTHENTICATION_MIXED) {
    return (ldap_authentication_ldap_authenticated($user));
  // LDAP_authen.login_forms.MM.*  // show ldap help only if ldap authenticated in mixed mode

  }
  elseif ($auth_conf->authenticationMode == LDAP_AUTHENTICATION_EXCLUSIVE) {
    if ($user->uid == 0 || ldap_authentication_ldap_authenticated($user)) {
    // LDAP_authen.login_forms.EM.anon, LDAP_authen.login_forms.EM.ldap
      return TRUE;
    }
    else {
      return FALSE; // LDAP_authen.login_forms.EM.user1, LDAP_authen.login_forms.EM.drupal
    }
  }
}

function _ldap_authentication_err_text($error) {

  $msg = t('unknown error: ' . $error);
  switch ($error) {
    case LDAP_AUTHENTICATION_RESULT_FAIL_CONNECT:
    $msg = "Failed to connect to ldap server";
    break;

    case LDAP_AUTHENTICATION_RESULT_FAIL_BIND:
    $msg = "Failed to bind to ldap server";
    break;

    case LDAP_AUTHENTICATION_RESULT_FAIL_FIND:
    $msg =  t('Sorry, unrecognized username or password.');
    break;

    case LDAP_AUTHENTICATION_RESULT_FAIL_DISALLOWED:
    $msg = "User disallowed";
    break;

    case LDAP_AUTHENTICATION_RESULT_FAIL_CREDENTIALS:
    $msg =  t('Sorry, unrecognized username or password.');
    break;

    case LDAP_AUTHENTICATION_RESULT_FAIL_GENERIC:
    $msg = t('Sorry, unrecognized username or password.');
    break;

    case LDAP_AUTHENTICATION_RESULT_FAIL_SERVER:
    $msg = t('Authentication Server or Configuration Error.');
    break;

  }

  return $msg;
}


/**
 * @file
 * ldap_authn provides authentication against ldap server.
 */

/**
  * helper function for ldap_authn_form_user_login_block_alter and ldap_authn_form_user_login_alter
  *
  * hook_user is gone in drupal 7 so functionality can be replaced by
  * altering login form submit and validate functions
  * http://drupal.org/update/modules/6/7#remove_op
  *
  * if form is being generated on non https and is set in preferences, set warning and end form development
  *   add submit functions to form
  *   - make sure submit function is in the correct order; that is if ldap precedes drupal, make _ldap_authn_login_form_submit first.
  *   do not remove other authentication submit functions, just reorder.
  */
function _ldap_authentication_login_form_alter(&$form, &$form_state, $form_id) {

/**
 * make sure ldap_autentication is configured and valid first
 */

  if (!$auth_conf = ldap_authentication_get_valid_conf()) {
    return;
  }
  elseif (!$auth_conf->enabled_servers()) {
    return;
  }

  /**
   *
   * add validate function to test for ldap authentication
   * should be placed after user_login_authenticate_validate
   * 1. user_login_name_validate
   * 2. user_login_authenticate_validate
   * 3. external authentication validate functions
   * 4. user_login_final_validate
   *
   * as articulated above user_login_default_validators() in user.module
   *
   * without any other external authentication modules, this array will start out as:
   *    array('user_login_name_validate', 'user_login_authenticate_validate', 'user_login_final_validate')
   */

  if (@in_array('user_login_authenticate_validate', $form['#validate'])) {
    $new_validation_sequence = array();
    foreach ($form['#validate'] as $validate_function_name) {
      if ($validate_function_name == 'user_login_authenticate_validate') {
        if ($auth_conf->authenticationMode == LDAP_AUTHENTICATION_MIXED) {
         // if mixed mode, allow drupal authentication first
          $new_validation_sequence[] = 'user_login_authenticate_validate';
          $new_validation_sequence[] = 'ldap_authentication_user_login_authenticate_validate';
        }
        elseif ($auth_conf->authenticationMode == LDAP_AUTHENTICATION_EXCLUSIVE) {
         // see drupal.org/node/1009990 and drupal.org/node/1022362 change back when fixed.
          $new_validation_sequence[] = 'user_login_authenticate_validate';
          $new_validation_sequence[] = 'ldap_authentication_user_login_authenticate_validate';
        }
        else { // misconfigured ldap authentication, restore to original validation sequence
        $new_validation_sequence[] = 'user_login_authenticate_validate';
        }
      }
      else {
        $new_validation_sequence[] = $validate_function_name;
      }
    }
  $form['#validate'] = $new_validation_sequence;
  }

  if ($form_id == 'user_login_block') {
    $user_register = variable_get('user_register', USER_REGISTER_VISITORS_ADMINISTRATIVE_APPROVAL);
    $vars = array(
      'show_reset_pwd' => ldap_authentication_show_reset_pwd(),
      'auth_conf' => $auth_conf,
      );

    $form['links']['#markup'] = theme('ldap_authentication_user_login_block_links', $vars);
  }
  ldap_servers_disable_http_check($form);
}
